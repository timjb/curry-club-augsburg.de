<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <title>Scheinbar unmögliche Programme :: Curry Club Augsburg</title>
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="shortcut icon" href="../images/favicon.ico" />
    <link rel="alternate" type="application/atom+xml" href="../atom.xml" />
    <link rel="alternate" type="application/rss+xml" href="../rss.xml" />
    <link rel="stylesheet" href="https://api.tiles.mapbox.com/mapbox.js/v2.1.6/mapbox.css" />
  </head>
  <body>
    <div class="wrap">
      <div class="main">
        <header>
          <div id="logo">
            <a href="../">
              <img src="../images/logo-dunkler-hintergrund.svg" alt="Curry Club Augsburg" />
            </a>
          </div>
          <blockquote>
            <p>Das wird heiß</p>
            <footer>
              &mdash; <cite class="author">Makarius</cite>
            </footer>
          </blockquote>
          <div class="clear"></div>
        </header>

        <main id="content">
          <article>
  <header>
    <h1>Scheinbar unmögliche Programme</h1>
    <div class="info">
      Gepostet am  6. Dez 15
      
          von Ingo Blechschmidt
      
    </div>
    
    
  </header>

  <div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Maybe</span></code></pre></div>
<p>Mit <code>[Bool]</code> meinen wir den Typ der unendlichen 0/1-Folgen.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> p1, p2,<span class="ot"> p3 ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> p1 xs <span class="fu">=</span> xs<span class="fu">!!</span><span class="dv">3</span>
<span class="ot">&gt;</span> p2 xs <span class="fu">=</span> xs<span class="fu">!!</span><span class="dv">4</span>
<span class="ot">&gt;</span> p3 xs <span class="fu">=</span> xs<span class="fu">!!</span>(<span class="dv">2</span><span class="fu">+</span><span class="dv">1</span>) <span class="fu">&amp;&amp;</span> (xs<span class="fu">!!</span><span class="dv">8</span> <span class="fu">||</span> not (xs<span class="fu">!!</span><span class="dv">8</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> test1 <span class="fu">=</span> p1 <span class="fu">==</span> p2
<span class="ot">&gt;</span> test2 <span class="fu">=</span> p1 <span class="fu">==</span> p3</code></pre></div>
<p>Das liefert einen Fehler über eine fehlende <code>Eq</code>-Instanz, oder? Weit gefehlt! Beide Programme terminieren. <code>test1</code> hat den Wert <code>False</code>, <code>test2</code> hat den Wert <code>True</code>.</p>
<p>Das ist umso erstaunlicher, wenn man bedenkt, dass <code>[Bool]</code> <em>überabzahlbar unendlich groß ist</em>.</p>
<p><strong>Hintergrund: Abzählbarkeit und Überabzählbarkeit</strong></p>
<p>Eine Menge heißt genau dann <em>abzählbar</em>, wenn es eine unendliche Liste gibt, in der alle Elemente der Menge vorkommen.</p>
<p>Prototypbeispiel: Die Menge N der natürlichen Zahlen ist abzählbar.</p>
<pre><code>0, 1, 2, 3, 4, ...</code></pre>
<p>Die Menge Z der ganzen Zahlen ist ebenfalls abzählbar, insbesondere also genau so groß wie die Menge der natürlichen Zahlen:</p>
<pre><code>0, 1, -1, 2, -2, 3, -3, 4, -4, 5, -5, ...</code></pre>
<p>Übungsaufgabe: Zeige, dass auch die Menge Q der rationalen Zahlen abzählbar ist.</p>
<p>Eine Menge heißt genau dann <em>überabzählbar</em>, wenn sie nicht abzählbar ist.</p>
<p>Beispiel (Cantor): Die Menge R der reellen Zahlen ist überabzählbar.</p>
<p>Oder: Die Menge [Bool] aller unendlichen 0/1-Folgen ist überabzählbar.</p>
<p>Beweis durch das Cantorsche Diagonalargument:</p>
<p>Keine Liste von 0/1-Folgen kann <em>alle</em> 0/1-Folgen enthalten. Denn wenn zum Beispiel folgende Liste gegeben ist:</p>
<pre>
01000101011011011...
11101011111101111...
10101010101010101...
11100011100010010...
10010101100100000...
11010101100100000...
.
.
.
</pre>
<p>Wenn man nun die Diagonale (von oben links nach unten rechts) durchgeht, und jeweils die Gegenziffer wählt, erhält man eine 0/1-Folge, die sicher nicht in der Liste vorkommt. Im Beispiel wäre das</p>
<pre>100110...</pre>
<p>Diese 0/1-Folge kann nicht das erste Element der Liste sein, denn sie unterscheidet sich vom ersten Element ja an der vordersten Stelle. Sie kann auch nicht das zweite Element der Liste sein, denn sie unterscheidet sich vom zweiten Element ja an der zweitvordersten Stelle. Und so weiter!</p>
<p><strong>Epsilon</strong></p>
<p>Sei <code>p :: [Bool] -&gt; Bool</code> ein beliebiges Prädikat.</p>
<p>Falls <code>p</code> erfüllbar ist, d.h. falls es eine 0/1-Folge <code>xs</code> gibt, sodass <code>p xs</code>, dann soll <code>epsilon p</code> irgendeine 0/1-Folge sein, sodass <code>p (epsilon p)</code>.</p>
<p>Falls <code>p</code> nicht erfüllbar ist, dann kann <code>epsilon p</code> sein, was es möchte.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; epsilon ::</span> ([<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [<span class="dt">Bool</span>]
<span class="ot">&gt;</span> epsilon p <span class="fu">=</span> <span class="kw">if</span> p (<span class="dt">False</span> <span class="fu">:</span> xs)
<span class="ot">&gt;</span>     <span class="kw">then</span> <span class="dt">False</span> <span class="fu">:</span> xs
<span class="ot">&gt;</span>     <span class="kw">else</span> <span class="dt">True</span>  <span class="fu">:</span> epsilon (p <span class="fu">.</span> (<span class="dt">True</span><span class="fu">:</span>))
<span class="ot">&gt;</span>     <span class="kw">where</span> xs <span class="fu">=</span> epsilon (p <span class="fu">.</span> (<span class="dt">False</span><span class="fu">:</span>))</code></pre></div>
<p>Etwas schneller geht es dank Lazyness so:</p>
<pre><code>epsilon :: ([Bool] -&gt; Bool) -&gt; [Bool]
epsilon p = h : epsilon (p . (h:))
    where
    h = not $ p (False : epsilon (p . (False:)))</code></pre>
<p>Wer es noch schneller möchte – sodass auch Code wie <code>epsilon $ \xs -&gt; xs !! (10^10)</code> funktioniert, kann sich den Code von Martín Escardó ansehen.</p>
<p><strong>exists</strong></p>
<p>Sei <code>p :: [Bool] -&gt; Bool</code> ein beliebiges Prädikat.</p>
<p>Falls <code>p</code> erfüllbar ist, dann soll <code>exists p</code> ein Zeuge dieser Erfüllbarkeit sein (in einem Maybe verpackt), also eine 0/1-Folge <code>xs</code>, sodass <code>p xs</code>.</p>
<p>Falls <code>p</code> nicht erfüllbar ist, soll <code>exists p</code> <code>Nothing</code> sein.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; exists ::</span> ([<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Bool</span>]
<span class="ot">&gt;</span> exists p <span class="fu">=</span> <span class="kw">if</span> p xs <span class="kw">then</span> <span class="dt">Just</span> xs <span class="kw">else</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>     <span class="kw">where</span> xs <span class="fu">=</span> epsilon p</code></pre></div>
<p><strong>forall</strong></p>
<p>Sei <code>p :: [Bool] -&gt; Bool</code> ein beliebiges Prädikat.</p>
<p><code>forall p</code> soll dann und nur dann True sein, falls `<code>p auf jeder 0/1-Folge konstant</code>True` ist.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; forall ::</span> ([<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> forall p <span class="fu">=</span> isNothing <span class="fu">$</span> exists (not <span class="fu">.</span> p)</code></pre></div>
<p>Punktfrei geht es auch:</p>
<p><code>forall = not . isJust . exists . (not .)</code></p>
<p><strong>Eq-Instanz für Funktionen [Bool] -&gt; Bool</strong></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Eq</span> ([<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="kw">where</span>
<span class="ot">&gt;</span>     f <span class="fu">==</span> g <span class="fu">=</span> forall <span class="fu">$</span> \xs <span class="ot">-&gt;</span> f xs <span class="fu">==</span> g xs
<span class="ot">&gt;</span>     <span class="co">-- &quot;zwei Prädikate sind genau dann gleich, wenn sie auf jedem Argument</span>
<span class="ot">&gt;</span>     <span class="co">-- gleich sind&quot;</span></code></pre></div>
<p><strong>Exkurs: Beispiel für eine unstetige Funktion</strong></p>
<p>Eine Funktion von R nach R ist genau dann stetig, wenn man ihren Graph zeichnen kann, ohne den Stift abzusetzen. Eine stetige Funktion darf also keine Sprungstellen besitzen.</p>
<pre>
f : R --> R

x |-> if x < 0 then -1 else if x == 0 then 0 else 1

</pre>
<p>Die Signumfunktion!</p>
<p>Sie ist aber nur definiert auf der Teilmenge</p>
<pre>{ x in R | x < 0 oder x = 0 oder x > 0 }.</pre>
<p>Konstruktiv kann man nicht zeigen, dass diese Teilmenge ganz R ist. Die Funktion ist also nicht als total nachweisbar.</p>
<p><strong>Wieso funktionieren die “scheinbar unmöglichen Programme”?</strong></p>
<ol style="list-style-type: decimal">
<li><p>In Haskell kann man nur stetige Funktionen implementieren. (Wie in manchen Schulen konstruktiver Mathematik auch.) Jede Funktion vom Typ <code>[Bool] -&gt; Bool</code> ist stetig.</p></li>
<li><p>In der Topologie gibt es folgenden Satz: Jede stetige Funktion, deren Definitionsmenge kompakt ist, ist schon gleichmäßig stetig.</p></li>
</ol>
<p>Die Menge <code>[Bool]</code> ist kompakt. (Eigentlich sollte man “Raum” statt “Menge” sagen. Für Topologie-Fans: Das folgt sofort aus dem Satz von Tychonoff.)</p>
<ol start="3" style="list-style-type: decimal">
<li><p>Im Spezialfall von Funktionen <code>[Bool] -&gt; Bool</code> bedeutet gleichmäßig stetig: Eine solche Funktion ist genau dann gleichmäßig stetig, wenn es eine Schranke <code>m</code> gibt, sodass die Funktion zur Berechnung ihres Ergebnisses nur die ersten <code>m</code> Bits der Folge benötigt (unabhängig von der speziellen Eingabefolge).</p></li>
<li><p><code>epsilon</code> ruft sich selbst rekursiv auf. Wenn <code>p</code> als Schranke <code>m</code> hat, dann hat das im rekursiven Aufruf verwendete Prädikat <code>(p . (False:))</code> als Schranke <code>m-1</code>. Also terminiert nach <code>m</code> rekursiven Aufrufen das Verfahren.</p></li>
</ol>
<p><strong>Und die Moral von der Geschicht</strong></p>
<p>In der Frage, ob Gleichheit von Funktionen vom Typ <code>A -&gt; Bool</code> entscheidbar ist, ist es nicht relevant, ob <code>A</code> endlich ist oder nicht. Tatsächlich entscheidend ist, ob <code>A</code> <em>kompakt</em> ist oder nicht.</p>
<ul>
<li>Endliche Typen sind kompakt.</li>
<li><code>[Bool]</code> ist kompakt.</li>
<li>Sind <code>A</code> und <code>B</code> kompakt, so auch der Produkttyp <code>(A,B)</code>.</li>
<li><code>Nat</code> und <code>Integer</code> sind nicht kompakt.</li>
<li>Der Datentyp der “lazy naturals”, welche auch <code>+infty</code> enthalten, ist kompakt.</li>
</ul>
<p><strong>Übungsaufgaben:</strong></p>
<ol style="list-style-type: decimal">
<li>Übertrage die Funktion <code>epsilon</code> – und damit auch <code>exists</code> und <code>forall</code>, auf den Fall von Funktionen <code>NAT -&gt; Bool</code> (statt <code>[Bool] -&gt; Bool</code>). Dabei soll <code>NAT</code> der Typ der “lazy naturals” sein, zum Beispiel definiert durch:</li>
</ol>
<p><code>data NAT = Zero | Succ NAT</code></p>
<p><code>infty = Succ infty</code></p>
<ol start="2" style="list-style-type: decimal">
<li>Definiere eine Typklasse <code>Compact</code> und implementiere Instanzen für <code>[Bool]</code> und <code>NAT</code> sowie eine generische Instanz <code>(Compact a, Compact b) =&gt;    Compact (a,b)</code>.</li>
</ol>
<p><strong>Diesen Text gibt es auch als <a href="https://github.com/iblech/vortrag-haskell/blob/master/impossible-programs.lhs">kompilierbares Literate Haskell</a>!</strong></p>
</article>

        </main>
      </div>
    </div>

    <footer class="footer">
      Mit viel <b>&lambda;</b> und mit Hilfe von <a href="http://jaspervdj.be/hakyll">Hakyll</a> erstellt.
      Schau dir den <a href="https://github.com/curry-club-aux/curry-club-augsburg.de">Quellcode</a> an und verbessere ihn!<br />
      Sofern nicht anders angegeben, stehen Design, Bilder, Webseite und Texte unter <a href="https://creativecommons.org/licenses/by/3.0/de/">CC BY 3.0 DE</a> und Codeschnipsel unter <a href="https://opensource.org/licenses/MIT">MIT-Lizenz</a>.<br />
      Q: Warum sind alle Formulierungen auf der Website weiblich? A: Weil wir's können.
    </footer>
  </body>
</html>
